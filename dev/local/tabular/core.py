#AUTOGENERATED! DO NOT EDIT! File to edit: dev/40_tabular_core.ipynb (unless otherwise specified).

__all__ = ['Tabular', 'TabularProc', 'Categorify', 'Normalize', 'FillStrategy', 'FillMissing', 'process_df',
           'ReadTabLine', 'ReadTabTarget', 'ReadTabLine', 'ReadTabTarget', 'ReadTabBatch']

#Cell 0
from ..torch_basics import *
from ..test import *
from ..core import *
from ..data.all import *
from ..notebook.showdoc import show_doc

#Cell 1
pd.set_option('mode.chained_assignment','raise')

#Cell 6
class Tabular(CollBase):
    def __init__(self, df, cat_names=None, cont_names=None, y_names=None, is_y_cat=True, splits=None):
        super().__init__(df)
        self.splits = L(ifnone(splits,slice(None)))
        self.cat_names,self.cont_names,self.y_names = L(cat_names),L(cont_names),y_names
        self.cat_y  = None if not is_y_cat else y_names
        self.cont_y = None if     is_y_cat else y_names

    def __setitem__(self,k,v): super().__setitem__(list(k) if isinstance(k,L) else k, v)
    def transform(self, cols, f): self[cols] = self[cols].transform(f)

    @property
    def loc(self): return self.items.loc
    @property
    def iloc(self): return self.items.iloc

    @property
    def all_cont_names(self): return self.cont_names + self.cont_y
    @property
    def all_cat_names (self): return self.cat_names  + self.cat_y
    @property
    def all_col_names (self): return self.all_cont_names + self.all_cat_names

#Cell 7
def _add_prop(cls, nm):
    prop = property(lambda o: o.items[list(getattr(o,nm+'_names'))])
    setattr(cls, nm+'s', prop)
    def _f(o,v): o.items[list(getattr(o,nm+'_names'))] = v
    setattr(cls, nm+'s', prop.setter(_f))

_add_prop(Tabular, 'cat')
_add_prop(Tabular, 'all_cat')
_add_prop(Tabular, 'cont')
_add_prop(Tabular, 'all_cont')
_add_prop(Tabular, 'all_col')

#Cell 8
class TabularProc(InplaceTransform):
    "Base class to write a tabular processor for dataframes"
    def process(self, *args,**kwargs): return self(*args,**kwargs)

#Cell 11
class Categorify(TabularProc, CollBase):
    "Transform the categorical variables to that type."
    order = 1
    def setup(self, to):
        to.classes = self.items = {n:CategoryMap(to.loc[to.splits[0],n], add_na=True)
                                   for n in to.all_cat_names}

    def _apply_cats(self, c): return c.cat.codes+1 if is_categorical_dtype(c) else c.map(self[c.name].o2i)
    def encodes(self, to): to.transform(to.all_cat_names, self._apply_cats)
    def decodes(self, to):
        cats = [[self[c][v] for v,c in zip(t, to.cat_names)] for t in to.items[0]]
        cat_y = to.items[2] if to.cat_y is None else [self[to.cat_y][v] for v in to.items[2]]
        to.items = (cats,to.items[1],cat_y)
        return to

#Cell 17
class Normalize(TabularProc):
    "Normalize the continuous variables."
    order = 2
    def setup(self, to):
        df = to.loc[to.splits[0], to.cont_names]
        self.means,self.stds = df.mean(),df.std(ddof=0)

    def encodes(self, to): to.conts = (to.conts-self.means) / (self.stds+1e-7)
    def decodes(self, to):
        conts = [[self.stds[c] * v.item() + self.means[c] for c,v in zip(to.cont_names, t)] for t in to.items[1]]
        to.items = (to.items[0], conts, to.items[2])
        return to

#Cell 21
class FillStrategy:
    "Namespace containing the various filling strategies."
    def median  (c,fill): return c.median()
    def constant(c,fill): return fill
    def mode    (c,fill): return c.dropna().value_counts().idxmax()

#Cell 22
class FillMissing(TabularProc):
    "Fill the missing values in continuous columns."
    def __init__(self, fill_strategy=FillStrategy.median, add_col=True, fill_vals=None):
        if fill_vals is None: fill_vals = defaultdict(int)
        store_attr(self, 'fill_strategy,add_col,fill_vals')

    def setup(self, to):
        df = to.loc[to.splits[0], to.cont_names]
        self.na_dict = {n:self.fill_strategy(df[n], self.fill_vals[n])
                        for n in pd.isnull(to.conts).any().keys()}

    def encodes(self, to):
        missing = pd.isnull(to.conts)
        for n in missing.any().keys():
            assert n in self.na_dict, f"nan values in `{n}` but not in setup training set"
            to[n].fillna(self.na_dict[n], inplace=True)
            if self.add_col:
                to[n+'_na'] = missing[n]
                if n+'_na' not in to.cat_names: to.cat_names.append(n+'_na')

#Cell 29
@delegates(Tabular)
def process_df(df, procs, inplace=True, **kwargs):
    "Process `df` with `procs` and returns the processed dataframe and the `TabularProcessor` associated"
    to = Tabular(df if inplace else df.copy(), **kwargs)
    proc = Pipeline(procs)
    proc.setup(to)
    return to,proc

#Cell 33
class ReadTabLine(ItemTransform):
    def __init__(self, proc): self.proc = proc

    def encodes(self, row):
        cats,conts = (o.mapped(row.__getitem__) for o in (self.proc.cat_names,self.proc.cont_names))
        return TensorTabular((tensor(cats).long(),tensor(conts).float()))

    def decodes(self, o) -> TabularLine:
        to = Tabular(o, self.proc.cat_names, self.proc.cont_names, self.proc.y_names)
        to = self.proc.decode(to)
        return pd.Series({c: v for v,c in zip(to.items[0]+to.items[1], self.proc.cat_names+self.proc.cont_names)})

#Cell 34
class ReadTabTarget(ItemTransform):
    def __init__(self, proc): self.proc = proc
    def encodes(self, row): return row[self.proc.y_names].astype(np.int64)
    def decodes(self, o) -> Category: return self.proc.classes[self.proc.y_names][o]

#Cell 35
class ReadTabLine(ItemTransform):
    def __init__(self, proc): self.proc = proc

    def encodes(self, row):
        cats,conts = (o.mapped(row.__getitem__) for o in (self.proc.cat_names,self.proc.cont_names))
        return TensorTabular((tensor(cats).long(),tensor(conts).float()))

    def decodes(self, o) -> TabularLine:
        to = Tabular(([o[0]], [o[1]], [0]), self.proc.cat_names, self.proc.cont_names, None)
        to = self.proc.decode(to)
        return pd.Series({c: v for v,c in zip(to.items[0][0]+to.items[1][0], self.proc.cat_names+self.proc.cont_names)})

#Cell 36
class ReadTabTarget(ItemTransform):
    def __init__(self, proc): self.proc = proc
    def encodes(self, row): return row[self.proc.y_names].astype(np.int64)
    def decodes(self, o) -> Category: return self.proc.classes[self.proc.y_names][o]

#Cell 45
class ReadTabBatch(ItemTransform):
    def __init__(self, proc): self.proc = proc

    def encodes(self, df):
        cats,conts,targ = (df[o] for o in (self.proc.cat_names,self.proc.cont_names,self.proc.y_names))
        return (TensorTabular((tensor(cats.values).long(),tensor(conts.values).float())), tensor(targ.values).long())

    def decodes(self, o)->TabularDF:
        (cats,conts),targs = o
        res = []
        to = Tabular((cats,conts,targs), self.proc.cat_names, self.proc.cont_names, self.proc.y_names, is_y_cat=self.proc.cat_y is not None)
        to = self.proc.decode(to)
        return pd.DataFrame({**{c: [t[i] for t in to.items[0]] for i,c in enumerate(self.proc.cat_names)},
                             **{c: [t[i] for t in to.items[1]] for i,c in enumerate(self.proc.cont_names)},
                             self.proc.y_names: [t for t in to.items[2]]})